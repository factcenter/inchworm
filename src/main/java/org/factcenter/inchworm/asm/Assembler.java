package org.factcenter.inchworm.asm;

import org.antlr.runtime.ANTLRInputStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.Tree;
import org.factcenter.inchworm.MemoryArea;
import org.factcenter.inchworm.UnsupportedArgException;
import org.factcenter.inchworm.VMState;
import org.factcenter.inchworm.ops.OpDefaults;
import org.factcenter.inchworm.ops.OpDesc;
import org.factcenter.inchworm.ops.dummy.DummyOPFactory;
import org.factcenter.inchworm.asm.InchwormAsmLexer;
import org.factcenter.inchworm.asm.InchwormAsmParser;
import org.factcenter.qilin.comm.SendableOutputStream;
import org.factcenter.qilin.util.BitMatrix;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;

import static org.factcenter.inchworm.Constants.NamedReg.R_NOP;

/**
 * Class implementing a two-pass assembler for compiling an Inchworm assembly
 * source code file into the binary machine state description expected by the
 * virtual CPU.
 */
public class Assembler {
	final static int MAX_PASSES = 3;

	/**
	 * The parser symbol table.
	 */
	HashMap<String, BigInteger> symbols;

	/**
	 * A table giving the position of the next mandatory op.
	 */
	int[] nextMandatoryOp;

	/**
	 * Inchworm virtual machine state object.
	 */
	VMState state;

	/**
	 * AST (generated by the ANTLR parser).
	 */
	CommonTree tree;

	/**
	 * Information about ops that is interesting only to the assembler, not the
	 * VM.
	 * 
	 * @author talm
	 *
	 */
	static class ExtraOpInfo {
		/**
		 * This op must be explicitly specified in every instruction.
		 */
		boolean mandatory;

		public ExtraOpInfo(boolean mandatory) {
			this.mandatory = mandatory;
		}
	}

	class UnresolvedSymbolException extends TreeRecognitionException {
		private static final long serialVersionUID = 1L;

		UnresolvedSymbolException(Tree node, String message) {
			super(node, message);
		}
	}

	/**
	 * Constructs a new {@code Assembler} object.
	 * 
	 * @param state
	 *            - Inchworm virtual machine state object.
	 * @param symbols
	 *            - The parser symbol table.
	 */
	public Assembler(VMState state, HashMap<String, BigInteger> symbols) {
		this.symbols = symbols;
		this.state = state;
	}

	/**
	 * Constructs a new {@code Assembler} object.
	 * 
	 * @param state
	 *            - Inchworm virtual machine state object.
	 */
	public Assembler(VMState state) {
		this(state, new HashMap<String, BigInteger>());
	}

	/**
	 * TreeRecognitionException is the superclass of the ANTLR
	 * RecognitionException that can be thrown during the normal operations on
	 * the AST nodes. This exception can track where in the AST a problem
	 * occurred and /or what was the expected input.
	 */
	public class TreeRecognitionException extends RecognitionException {
		private static final long serialVersionUID = 1L;

		Tree node;
		String message;

		TreeRecognitionException(Tree node, String message) {
			this.node = node;
			this.message = message;
		}

		public String toString() {
			return message + " (Line " + node.getLine() + ":"
					+ node.getCharPositionInLine() + ")";
		}
	}

	/**
	 * First pass assembly (including AST).
	 * 
	 * @param in
	 *            - the source code file.
	 * @throws IOException
	 * @throws RecognitionException
	 */
	void firstPassAssemble(InputStream in) throws IOException,
			RecognitionException {
		CommonTokenStream tokens = new CommonTokenStream();

		ANTLRInputStream input = new ANTLRInputStream(in);
		org.factcenter.inchworm.asm.InchwormAsmLexer lexer = new org.factcenter.inchworm.asm.InchwormAsmLexer(input);
		tokens.setTokenSource(lexer);

		org.factcenter.inchworm.asm.InchwormAsmParser parser = new org.factcenter.inchworm.asm.InchwormAsmParser(tokens);
		parser.initState(state, symbols);
		InchwormAsmParser.program_return program = parser.program();

		tree = (CommonTree) program.getTree();
		ArrayList<ExtraOpInfo> opInfo = parser.opInfo;
		nextMandatoryOp = new int[opInfo.size()];
		int lastMandatory = -1;
		for (int i = opInfo.size() - 1; i >= 0; --i) {
			if (opInfo.get(i).mandatory) {
				lastMandatory = i;
			}
			nextMandatoryOp[i] = lastMandatory;
		}
	}

	/**
	 * Return the value of a constant expression.
	 * 
	 * @param root
	 *            the root of the expression tree
	 * @param curPointer
	 *            the current position (used to replace '$')
	 * @return the integer value of the expression.
	 */
	BigInteger exprWalk(Tree root, int curPointer) throws RecognitionException {
		BigInteger val = BigInteger.ZERO;
		switch (root.getType()) {
		// Atoms
		case InchwormAsmParser.NUM:
			// We use Long rather than Integer to support 32 bit unsigned ints.
			val = new BigInteger(root.getText(), 16);
			break;
		case InchwormAsmParser.HERE:
			val = BigInteger.valueOf(curPointer);
			break;
		case InchwormAsmParser.SYMBOL:
			String symId = root.getChild(0).getText();
			BigInteger symVal = symbols.get(symId);
			if (symVal == null)
				throw new UnresolvedSymbolException(root, "Unknown identifier "
						+ symId);
			val = symVal;
			break;
		case InchwormAsmParser.NOP:
			val = BigInteger.valueOf(state.getNumRegs() - R_NOP.getOffset());
			break;
		// Operators
		case InchwormAsmParser.C_ADD:
			val = exprWalk(root.getChild(0), curPointer).add(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_SUB:
			val = exprWalk(root.getChild(0), curPointer).subtract(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_MUL:
			val = exprWalk(root.getChild(0), curPointer).multiply(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_DIV:
			val = exprWalk(root.getChild(0), curPointer).divide(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_NOT:
			val = exprWalk(root.getChild(0), curPointer).not();
			break;
		case InchwormAsmParser.C_UNARY_MINUS:
			val = exprWalk(root.getChild(0), curPointer).negate();
			break;
		case InchwormAsmParser.C_MOD:
			val = exprWalk(root.getChild(0), curPointer).mod(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_XOR:
			val = exprWalk(root.getChild(0), curPointer).xor(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_AND:
			val = exprWalk(root.getChild(0), curPointer).and(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_OR:
			val = exprWalk(root.getChild(0), curPointer).or(
					exprWalk(root.getChild(1), curPointer));
			break;
		case InchwormAsmParser.C_SHL:
			val = exprWalk(root.getChild(0), curPointer).shiftLeft(
					exprWalk(root.getChild(1), curPointer).intValue());
			break;
		case InchwormAsmParser.C_SHR:
			val = exprWalk(root.getChild(0), curPointer).shiftRight(
					exprWalk(root.getChild(1), curPointer).intValue());
			break;
		default:
			throw new TreeRecognitionException(root,
					"Expected constant expression, not " + root.getText());
		}

		// val &= ((long)1 << state.getWordSize()) - 1;
        BigInteger mask = BigInteger.ONE.shiftLeft(state.getWordSize()).subtract(BigInteger.ONE);

		return val.and(mask);
	}

	/**
	 * Sets currently pending labels to a value and empties the list.
	 * 
	 * @param pendingLabels
	 * @param curReg
	 */
	private void setPendingLabels(ArrayList<String> pendingLabels, int curReg) {
		for (String label : pendingLabels) {
			symbols.put(label, BigInteger.valueOf(curReg));
		}
		pendingLabels.clear();
	}

	/**
	 * Walk over data nodes and write values to registers.
	 * 
	 * @param root
	 * @throws RecognitionException
	 */
	boolean dataWalk(Tree root, boolean allowUnresolved)
			throws RecognitionException, IOException {
		boolean fullyResolved = true;
		boolean curRegKnown = true;

		int curReg = 0;
		// W "label:" definition refers to the *following* address. We keep all
		// the currently
		// undefined labels in this list, and set them when we reach an address
		// definition or a
		// the end of the section.
		ArrayList<String> pendingLabels = new ArrayList<String>();

		if (root.getType() != InchwormAsmParser.DATA)
			throw new TreeRecognitionException(root, "Expected Data Section");

		for (int i = 0; i < root.getChildCount(); ++i) {
			curReg %= state.getNumRegs();

			Tree child = root.getChild(i);

			switch (child.getType()) {
			case InchwormAsmParser.ID:
				pendingLabels.add(child.getText());
				break;
			case InchwormAsmParser.CURRENT_POS:
				if (curRegKnown)
					setPendingLabels(pendingLabels, curReg);
				break;
			case InchwormAsmParser.REG:
				try {
					curReg = exprWalk(child.getChild(0), curReg).intValue();
					curRegKnown = true;
					setPendingLabels(pendingLabels, curReg);
				} catch (UnresolvedSymbolException e) {
					if (!allowUnresolved)
						throw e;
					curRegKnown = fullyResolved = false;
				}
				break;
			case InchwormAsmParser.STRING:
				if (!curRegKnown)
					break;
				setPendingLabels(pendingLabels, curReg);
				byte[] textBytes = child.getText().getBytes();
				// Write string bytes into registers packed wordsize bits at a
				// time.
				// With zero padding at the end (if necessary).
				int curval = 0;
				int leftOver = state.getWordSize();
				for (int srcpos = 0; srcpos < textBytes.length; ++srcpos) {
					if (leftOver > 7) {
						curval <<= 8;
						curval |= ((int) textBytes[srcpos]) & 0xff;
						leftOver -= 8;
						if (leftOver == 0) {
							// we filled a register, advance to the next one.
							state.putReg(curReg++, curval);
							leftOver = state.getWordSize();
							curval = 0;
						}
					} else if (leftOver > 0) {
						curval <<= leftOver;
						curval |= (((int) textBytes[srcpos]) & 0xff) >>> (8 - leftOver);
						state.putReg(curReg++, curval);
						curval = ((int) textBytes[srcpos])
								& ((1 << (8 - leftOver)) - 1);
						leftOver = state.getWordSize() - (8 - leftOver);
					}
				}
				break;
			default:
				if (!curRegKnown)
					break;
				setPendingLabels(pendingLabels, curReg);

				try {
					// Must be constant expression.
					BigInteger constval = exprWalk(child, curReg);
					state.putReg(curReg++, BitMatrix.valueOf(constval, state.getWordSize()));
				} catch (UnresolvedSymbolException e) {
					if (!allowUnresolved)
						throw e;
					fullyResolved = false;
					curReg++;
				}
				break;
			}
		}
		if (curRegKnown)
			setPendingLabels(pendingLabels, curReg);
		return fullyResolved;
	}

	/**
	 * Walk over instruction nodes and write machine-code to ROM
	 * 
	 * @param root
	 * @throws RecognitionException
	 */
	// Note: we assume that the Op.getEnum method will recognize the instruction
	// text that found by the ANTLR parser.
	void instructionWalk(Tree root, boolean allowUnresolved)
			throws RecognitionException, IOException {
		if (root.getType() != InchwormAsmParser.INSTRUCTION)
			throw new TreeRecognitionException(root, "Expected Instruction");

		// The index of the current instruction
		int instNum = exprWalk(root.getChild(0), 0).intValue();

		// The index of the current op within the instruction.
		int opNum = 0;

		for (int i = 0; i < root.getChildCount() - 1; ++i) {
			Tree child = root.getChild(i + 1);
			OpDefaults.Op op = OpDefaults.Op.getEnum(child.getText());
			boolean opDivOrMul = ((op == OpDefaults.Op.OP_MUL) || (op == OpDefaults.Op.OP_DIV));
			if (op == null)
				throw new TreeRecognitionException(root, child.getText()
						+ " is not a valid instruction op");

			OpDesc opDesc = OpDefaults.getDefaultDesc(op);

			// Check to see if we skipped ops.
			int noSkip = nextMandatoryOp[opNum]; // can't skip this op
			opNum = state.getNextMatchingOp(opNum, opDesc);
			if (opNum == -2) {
				String message = String
						.format("%s (instr: 0x%03x, op: 0x%x) illegal op (not defined in instruction)",
								child.getText(), instNum, i);
				throw new TreeRecognitionException(root, message);
			} else if (noSkip >= 0 && (opNum < 0 || opNum > noSkip)) {
				String message = String
						.format("%s (instr: 0x%03x, op: 0x%x) skipped mandatory op %d (%s)",
								child.getText(), instNum, i, noSkip,
                                    state.getOpDescs().get(noSkip).name);
				throw new TreeRecognitionException(root, message);
			} else if (opNum < 0) {
				String message = String
						.format("%s (instr: 0x%03x, op: 0x%x) should be in next instruction",
								child.getText(), instNum, i);
				throw new TreeRecognitionException(root, message);
			}

			// Return actually does have a hidden operand which is inserted by
			// the assembler for each explicit use of the opcode, and set to -1.
			if (op == OpDefaults.Op.OP_RETURN) {
				state.putOpArg(instNum, opNum, 0, BitMatrix.allOnes(state.getWordSize()));
			}
			// Loop over op arguments
			for (int j = 0; j < child.getChildCount(); ++j) {
				try {
					Tree opArg = child.getChild(j);
					BigInteger opVal;
					if (opArg.getType() == InchwormAsmParser.REG) {
						// The actual argument is one level down
						opVal = exprWalk(opArg.getChild(0), instNum);
						if (opDivOrMul) {
							if (j == 0) {
								if (opVal.testBit(0)) {
									String message = String
											.format("Destination reg for op %s should be even",
													op);
									throw new UnsupportedArgException(message);
								}
							}
						}
					} else {
						// This is an immediate
						opVal = exprWalk(opArg, instNum);
						if (op == OpDefaults.Op.OP_CALL) {
							// set the operand high-order bit.
                            state.putOpArg(instNum, opNum, 0, BitMatrix.allOnes(state.getWordSize()));
							++j; // This will affect the next putOpArg,
									// and then the loop will terminate
						}
					}
					state.putOpArg(instNum, opNum, j, BitMatrix.valueOf(opVal, state.getWordSize()));
				} catch (UnresolvedSymbolException e) {
					if (!allowUnresolved)
						throw e;
				}
			}
			++opNum;
		}
	}

	/**
	 * Walk over the AST nodes and executes the child-nodes walkers.
	 * 
	 * @param root
	 * @throws RecognitionException
	 */
	boolean nodeWalk(Tree root, boolean allowUnresolved)
			throws RecognitionException, IOException {
		boolean fullyResolved = true;
		switch (root.getType()) {
		default:
			// For unknown node types, just parse the children in sequence
			for (int i = 0; i < root.getChildCount(); ++i) {
				Tree child = root.getChild(i);
				fullyResolved &= nodeWalk(child, allowUnresolved);
			}
			return fullyResolved;
		case InchwormAsmParser.HEADER:
			return true;
		case InchwormAsmParser.CONST:
			// Constants section. We need to update our symbol table.
			for (int i = 0; i < root.getChildCount(); ++i) {
				Tree child = root.getChild(i);
				if (child.getType() != InchwormAsmParser.ID)
					throw new TreeRecognitionException(root,
							"Expected Identifier");
				String sym = child.getText();
				try {
					BigInteger val = exprWalk(child.getChild(0), 0);
					symbols.put(sym, val);
				} catch (UnresolvedSymbolException e) {
					fullyResolved = false;
				}
			}
			break;
		case InchwormAsmParser.DATA:
			fullyResolved &= dataWalk(root, allowUnresolved);
			break;
		case InchwormAsmParser.RAM:
			fullyResolved &= ramWalk(root, false); // never allow unresolved symbols in ram, for the timebeing.
			break;
		case InchwormAsmParser.CODE:
			// List of instructions. We do final symbol resolution and actual
			// assembly here.
			for (int i = 0; i < root.getChildCount(); ++i) {
				Tree child = root.getChild(i);
				instructionWalk(child, allowUnresolved);
			}
			break;
		}
		return fullyResolved;
	}

	private boolean ramWalk(Tree root, boolean allowUnresolved) throws RecognitionException, IOException {
		boolean fullyResolved = true;
		// todo: I'm not sure I understand if i need the fullyresolved flag for memory definitions. 
		// seems to me that one pass should do if we're only entering data.
				// if we have pointer circles, then we probably have a problem. We might actually want
		// to make this possible. ahh, later.
		assert(state.getRamWordSize() % 8 == 0); // Only support whole-byte-multiple sized ram words for now.
		BigInteger curRamWord = BigInteger.ZERO;
        // Current memory pointer. Note that RAM pointer can point to middle of RAM word
        // if ramAlignment is greater than 0.
		int curRamPtr = 0;
		int numBytesInRamWord = state.getRamWordSize()/8;
		int curByteIndexInWord = 0;
		MemoryArea ram = state.getMemory(MemoryArea.Type.TYPE_RAM);
		// W "label:" definition refers to the *following* address. We keep all
		// the currently
		// undefined labels in this list, and set them when we reach an address
		// definition or a
		// the end of the section.
		ArrayList<String> pendingLabels = new ArrayList<String>();

		if (root.getType() != InchwormAsmParser.RAM)
			throw new TreeRecognitionException(root, "Expected RAM Section");

		for (int i = 0; i < root.getChildCount(); ++i) {
			assert(curRamPtr < (state.getRamSize() - 1) * state.getWordSize()); // -1 because the last cell is the nop cell.

			Tree child = root.getChild(i);

			switch (child.getType()) {
			case InchwormAsmParser.ID:
				// todo: no such thing as pending labels here (unlike in registers).
				// labels always start from 0.
				pendingLabels.add(child.getText());
				break;
			default:
				// labels are pointers, and pointers are to units of size ramWordSize / (2^ramAlignment)
				// memory is padded with the default memory value for initialization
				// sequences that dont align with a word in the end.
				setPendingLabels(pendingLabels, curRamPtr);

				try {
					// Must be constant expression.
					BigInteger constVal = exprWalk(child, curRamPtr);
                    ram.store(curRamPtr++, BitMatrix.valueOf(constVal, state.getRamWordSize()));
				} catch (UnresolvedSymbolException e) {
					if (!allowUnresolved)
						throw e;
					fullyResolved = false;
					++curRamPtr;
				}
				break;
			}
		}
		return fullyResolved;
	}

	/**
	 * Full two-pass assembly. Output is written into {@link #state} that was
	 * input in the constructor.
	 * 
	 * @param in
	 *            Character stream for assembly source.
	 * @param initialize
	 *            whether to initialize memory. Set this to false when assembly
	 *            should continue without resetting existing data and code.
	 * @throws RecognitionException
	 * @throws IOException
	 */
	public void assemble(InputStream in, boolean initialize)
			throws RecognitionException, IOException {
		firstPassAssemble(in);
		// TODO: Fix when assembler supports setting ram wordsize directly
        // We currently set it to be the same as the register wordsize
        //state.setRamWordSize(state.getWordSize());
		if (state.getWordSize() > state.getRomPtrSize()) {
			if (initialize)
				state.initMemory();
			else {
                // Check if ROM is correct size, otherwise we need to initialize anyway
				MemoryArea rom = state.getMemory(MemoryArea.Type.TYPE_ROM);
                if (rom.getBlockCount() != state.getRomSize() ||
                        rom.getBlockSize() != state.getInstByteLen() * 8) {
					// ROM size is bad; we need to initialize it.
					state.initROM(true);
				}
			}

			boolean resolved = false;

			for (int i = 0; !resolved && (i < MAX_PASSES - 1); ++i)
				resolved = nodeWalk(tree, true);

			// todo: something is wrong with the logic here. even though there are unresolved code symbols, it still only does
			// one pass. so do a last pass to make sure ALWAYS.
			nodeWalk(tree, false);

		} else {
			String message = String
					.format("VMState WordSize (%d) must be greater than RomPtrSize (%d)",
							state.getWordSize(), state.getRomPtrSize());
			throw new UnsupportedArgException(message);
		}

	}

	/**
	 * Calls {@link #assemble(InputStream, boolean)} with initialize=true.
	 * 
	 * @param in
	 * @throws RecognitionException
	 * @throws IOException
	 */
	public void assemble(InputStream in) throws RecognitionException,
			IOException {
		assemble(in, true);
	}

	/**
	 * Return the symbol table generated by the parser.
	 */
	public HashMap<String, BigInteger> getSymbols() {
		return symbols;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		VMState state = new VMState();
		state.setMemory(new DummyOPFactory());
		Assembler asm = new Assembler(state);

		try {
			asm.assemble(new FileInputStream(System.getProperty("user.dir")
					+ "/test-asm.txt"));
			DisAssembler.disassemble(state, System.out, true);

			SendableOutputStream out = new SendableOutputStream(
					new FileOutputStream(System.getProperty("user.dir")
							+ "/test-asm.ivm"));
			state.store(out);
			out.close();
		} catch (IOException e) {
			System.err.println(e.toString());
			return;
		} catch (RecognitionException e) {
			System.err.println(e.toString());
			System.exit(-1);
			return;
		}
	}
}
